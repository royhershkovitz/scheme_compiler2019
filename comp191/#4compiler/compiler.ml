#use "code-gen.ml";;

exception X_missing_input_file;;
let file_to_string f =
  let ic = open_in f in
  let s  = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

 (* TODO
 GENERATE SHOULD support:
  | Var' get bound, param
  | Set' of expr' * expr' set in env? what if not there?
  | Def' of expr' * expr' add to env?
  | LambdaSimple' make closure magic
  | LambdaOpt' make closure
  | ApplicTP' prepare and exit;;
 Some of the built-in procedures are left for you to implement as primitive assembly procedures:
apply (variadic), done -> car, cdr, cons, set-car!, and set-cdr!.*)
let primitive_names_to_labels = 
  ["even?","even_val";"apply","apply";
  "car", "get_car";"cdr", "get_cdr"; "cons", "cons"; "set-car!", "set_car"; "set-cdr!", "set_cdr";
   "boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
   "null?", "is_null"; "char?", "is_char"; "vector?", "is_vector"; "string?", "is_string";
   "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
   "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
   "vector-length", "vector_length"; "vector-ref", "vector_ref"; "vector-set!", "vector_set";
   "make-vector", "make_vector"; "symbol->string", "symbol_to_string"; 
   "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
   "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ"];;

let make_prologue consts_tbl fvars_tbl =
  (*let get_const_address const = 
    let const_row = List.find (fun (c, (_, _)) -> expr'_eq (Const'(const)) (Const'(c))) consts_tbl in
    let offset = (fun (_, (offset, _)) -> offset) const_row in
    "const_tbl + "^string_of_int offset in*)
  let get_fvar_address fvar =
    let fvar_row = List.find (fun (name, _) -> fvar = name) fvars_tbl in
    let offset = (fun (_, offset) -> offset) fvar_row in
    "fvar_tbl + WORD_SIZE*"^string_of_int offset in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [" ^ (get_fvar_address prim)  ^ "], rax" in
  let make_constant (_, (_, s)) = s in
  let make_symbol_tbl (name, index) =
    let st_string = List.map ((fun(ch) -> string_of_int (Char.code ch))) (string_to_list name) in
    let st_string = String.concat "," st_string in
    let index = string_of_int index in
    "sym"^index^":
    db "^st_string^", 0" in  
"
;;; All tconst_tbl and the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"
%include \"prims.s\"
section .bss
malloc_pointer:
    resq 1

section .data
const_tbl:
  " ^ (String.concat "\n\t" (List.map make_constant consts_tbl)) ^ "
fvar_tbl:
  " ^ (String.concat "\n\t" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "
symbols_tbl:
  " ^ (String.concat "\n\t" (List.map make_symbol_tbl fvars_tbl)) ^ "
global main
not_enough_ram:
    mov rax, 0
	  mov rdi, .exit_malloc
	  call printf

    mov rax, 60       
    mov rdi, -1     ;EXIT_Failure
    syscall
section .data
.exit_malloc: 
    db \"Failure! not enough ram!\",0 
wanted_ram:
  dq GB(4)
malloc_end:
  dq 0

section .text
main:
    ;; set up the heap
    mov rdi, qword [wanted_ram]
    call malloc
    cmp rax, 0
    je not_enough_ram
    mov [malloc_pointer], rax
    add rax, qword [wanted_ram]
    mov [malloc_end],   rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push qword 0
    push qword SOB_EMPTY_ENV

    call code_fragment
    add rsp, 2*8
    ret

code_fragment:
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
    push rbp
    mov rbp, rsp

"^ (String.concat "\n  " (List.map make_primitive_closure primitive_names_to_labels)) ^ "
love:";;

module type COMPILER = sig
  val build : string -> unit
end;;
module Compiler : COMPILER = struct

let build code = 
  let asts = string_to_asts code in
  (*print_string "ast_built\n";*)
  let consts_tbl = Code_Gen.make_consts_tbl asts in
  (*print_string "consts_tbl_built\n";*)
  
  let todo_add_to_fvars_tbl  = List.map 
            (fun (scheme_name,_) -> scheme_name) primitive_names_to_labels in
  let fvars_tbl = Code_Gen.make_fvars_tbl asts todo_add_to_fvars_tbl in

  (*print_string "fvars_tbl_built\n";*)
  let generate = Code_Gen.generate consts_tbl fvars_tbl in
  (*print_string "code_gen_built\n";
  print_string code;*)
  let code_fragment = String.concat "\n\n\t\t"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n\t\tcall write_sob_if_not_void")
                           asts) ^ "\n\tret" in (* forum suggestion *)
  (*print_string "code_fragment_built\n";*)
  print_string ((make_prologue consts_tbl fvars_tbl) ^ "\n\t\t" ^ code_fragment);;
(*try  *)
  let infile = Sys.argv.(1) in
  let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in
  (build code)
(*with Invalid_argument(x) -> raise X_missing_input_file;;*)
end;;
